import{_ as l,c as o,o as a,ah as i}from"./chunks/framework.ptg7Kx6M.js";const g=JSON.parse('{"title":"next 常用 API","description":"","frontmatter":{"title":"next 常用 API","date":"2025-09-04T00:00:00.000Z","category":"next","tags":["next","API"]},"headers":[],"relativePath":"posts/framework/next/common-api.md","filePath":"posts/framework/next/common-api.md"}'),t={name:"posts/framework/next/common-api.md"};function r(s,e,n,c,d,u){return a(),o("div",null,e[0]||(e[0]=[i('<h1 id="next-js-常用函数与方法总结" tabindex="-1">Next.js 常用函数与方法总结 <a class="header-anchor" href="#next-js-常用函数与方法总结" aria-label="Permalink to &quot;Next.js 常用函数与方法总结&quot;">​</a></h1><h2 id="api-篇-上" tabindex="-1">API 篇（上） <a class="header-anchor" href="#api-篇-上" aria-label="Permalink to &quot;API 篇（上）&quot;">​</a></h2><h3 id="_1-fetch" tabindex="-1">1. fetch <a class="header-anchor" href="#_1-fetch" aria-label="Permalink to &quot;1. fetch&quot;">​</a></h3><ul><li><strong>介绍</strong><ul><li>扩展原生 <code>fetch</code>，支持缓存控制</li><li>服务端组件中可使用 <code>async/await</code></li></ul></li><li><strong>options.cache</strong><ul><li><code>force-cache</code>（默认）：优先从缓存读取</li><li><code>no-store</code>：每次请求都重新获取，不缓存</li></ul></li><li><strong>options.next.revalidate</strong><ul><li><code>false</code>：无限期缓存</li><li><code>0</code>：不缓存</li><li><code>number</code>：缓存 n 秒</li></ul></li><li><strong>options.next.tags</strong><ul><li>设置缓存标签，配合 <code>revalidateTag</code> 使用</li></ul></li></ul><h3 id="_2-cookies" tabindex="-1">2. cookies <a class="header-anchor" href="#_2-cookies" aria-label="Permalink to &quot;2. cookies&quot;">​</a></h3><ul><li><strong>介绍</strong><ul><li>读取/写入 cookie</li><li>动态函数，导致路由动态渲染</li></ul></li><li><strong>方法</strong><ul><li><code>get(name)</code>：获取单个 cookie</li><li><code>getAll(name?)</code>：获取所有匹配 cookie</li><li><code>has(name)</code>：判断是否存在</li><li><code>set(name, value, options)</code>：设置 cookie</li><li><code>delete(name)</code>：删除 cookie</li></ul></li></ul><h3 id="_3-headers" tabindex="-1">3. headers <a class="header-anchor" href="#_3-headers" aria-label="Permalink to &quot;3. headers&quot;">​</a></h3><ul><li><strong>介绍</strong><ul><li>读取请求头，只读</li><li>动态函数</li></ul></li><li><strong>方法</strong><ul><li><code>get()</code>, <code>has()</code>, <code>getAll()</code>, <code>forEach()</code> 等</li><li>继承 Web Headers API</li></ul></li></ul><h3 id="_4-nextrequest" tabindex="-1">4. NextRequest <a class="header-anchor" href="#_4-nextrequest" aria-label="Permalink to &quot;4. NextRequest&quot;">​</a></h3><ul><li><strong>介绍</strong><ul><li>扩展 Request API</li></ul></li><li><strong>cookies</strong><ul><li><code>set</code>, <code>get</code>, <code>getAll</code>, <code>delete</code>, <code>has</code>, <code>clear</code></li></ul></li><li><strong>nextUrl</strong><ul><li>扩展 URL API，支持 <code>pathname</code>, <code>searchParams</code></li></ul></li></ul><h3 id="_5-nextresponse" tabindex="-1">5. NextResponse <a class="header-anchor" href="#_5-nextresponse" aria-label="Permalink to &quot;5. NextResponse&quot;">​</a></h3><ul><li><strong>介绍</strong><ul><li>扩展 Response API</li></ul></li><li><strong>方法</strong><ul><li><code>json(data, options)</code>：返回 JSON 响应</li><li><code>redirect(url)</code>：重定向</li><li><code>rewrite(url)</code>：重写 URL（不改变地址栏）</li><li><code>next()</code>：继续中间件执行</li></ul></li></ul><h3 id="_6-redirect" tabindex="-1">6. redirect <a class="header-anchor" href="#_6-redirect" aria-label="Permalink to &quot;6. redirect&quot;">​</a></h3><ul><li><strong>介绍</strong><ul><li>服务端重定向（307）</li><li>可用于服务端组件、Server Actions</li></ul></li><li><strong>参数</strong><ul><li><code>path</code>: 目标路径</li><li><code>type</code>: <code>replace</code>（默认）或 <code>push</code></li></ul></li></ul><h3 id="_7-permanentredirect" tabindex="-1">7. permanentRedirect <a class="header-anchor" href="#_7-permanentredirect" aria-label="Permalink to &quot;7. permanentRedirect&quot;">​</a></h3><ul><li><strong>介绍</strong><ul><li>永久重定向（308）</li></ul></li><li><strong>参数同 redirect</strong></li></ul><h3 id="_8-notfound" tabindex="-1">8. notFound <a class="header-anchor" href="#_8-notfound" aria-label="Permalink to &quot;8. notFound&quot;">​</a></h3><ul><li><strong>介绍</strong><ul><li>抛出 404 错误</li><li>需配合 <code>not-found.js</code> 使用</li></ul></li></ul><h3 id="_9-useparams" tabindex="-1">9. useParams <a class="header-anchor" href="#_9-useparams" aria-label="Permalink to &quot;9. useParams&quot;">​</a></h3><ul><li><strong>介绍</strong><ul><li>客户端 Hook，获取动态路由参数</li></ul></li><li><strong>返回值</strong><ul><li>对象：<code>{ slug: &#39;xxx&#39; }</code> 或 <code>{ slug: [&#39;a&#39;, &#39;b&#39;] }</code></li></ul></li></ul><h3 id="_10-usepathname" tabindex="-1">10. usePathname <a class="header-anchor" href="#_10-usepathname" aria-label="Permalink to &quot;10. usePathname&quot;">​</a></h3><ul><li><strong>介绍</strong><ul><li>获取当前 pathname</li></ul></li><li><strong>返回值</strong><ul><li>字符串，如 <code>/dashboard</code></li></ul></li></ul><h3 id="_11-userouter" tabindex="-1">11. useRouter <a class="header-anchor" href="#_11-userouter" aria-label="Permalink to &quot;11. useRouter&quot;">​</a></h3><ul><li><strong>介绍</strong><ul><li>客户端路由控制</li></ul></li><li><strong>方法</strong><ul><li><code>push</code>, <code>replace</code>, <code>back</code>, <code>forward</code></li><li><code>refresh</code>, <code>prefetch</code></li></ul></li></ul><h3 id="_12-usesearchparams" tabindex="-1">12. useSearchParams <a class="header-anchor" href="#_12-usesearchparams" aria-label="Permalink to &quot;12. useSearchParams&quot;">​</a></h3><ul><li><strong>介绍</strong><ul><li>获取查询参数</li></ul></li><li><strong>返回值</strong><ul><li><code>URLSearchParams</code> 实例</li><li>支持 <code>get</code>, <code>has</code>, <code>getAll</code> 等</li></ul></li><li><strong>行为</strong><ul><li>静态渲染：触发客户端渲染（需 Suspense）</li><li>动态渲染：服务端可用</li></ul></li></ul><hr><h2 id="api-篇-下" tabindex="-1">API 篇（下） <a class="header-anchor" href="#api-篇-下" aria-label="Permalink to &quot;API 篇（下）&quot;">​</a></h2><h3 id="_1-generatestaticparams" tabindex="-1">1. generateStaticParams <a class="header-anchor" href="#_1-generatestaticparams" aria-label="Permalink to &quot;1. generateStaticParams&quot;">​</a></h3><ul><li><strong>介绍</strong><ul><li>构建时生成静态路径（替代 <code>getStaticPaths</code>）</li></ul></li><li><strong>用法</strong><ul><li>返回对象数组：<code>[{ id: &#39;1&#39; }, { id: &#39;2&#39; }]</code></li></ul></li><li><strong>参数</strong><ul><li>支持 <code>options.params</code>（父子段传参）</li></ul></li><li><strong>返回值</strong><ul><li>根据路由结构返回对应格式</li></ul></li></ul><h3 id="_2-generateviewport" tabindex="-1">2. generateViewport <a class="header-anchor" href="#_2-generateviewport" aria-label="Permalink to &quot;2. generateViewport&quot;">​</a></h3><ul><li><strong>介绍</strong><ul><li>自定义 viewport 元信息</li></ul></li><li><strong>方式</strong><ul><li>静态 <code>viewport</code> 对象</li><li>动态 <code>generateViewport</code> 函数</li></ul></li><li><strong>字段</strong><ul><li><code>themeColor</code>, <code>colorScheme</code>, <code>width</code>, <code>initialScale</code></li></ul></li></ul><h3 id="_3-revalidatepath" tabindex="-1">3. revalidatePath <a class="header-anchor" href="#_3-revalidatepath" aria-label="Permalink to &quot;3. revalidatePath&quot;">​</a></h3><ul><li><strong>介绍</strong><ul><li>按路径重新验证缓存</li></ul></li><li><strong>参数</strong><ul><li><code>path</code>: 路径字符串</li><li><code>type</code>: <code>&#39;page&#39;</code> 或 <code>&#39;layout&#39;</code></li></ul></li><li><strong>注意</strong><ul><li>不立即生效，下次访问时触发</li></ul></li></ul><h3 id="_4-revalidatetag" tabindex="-1">4. revalidateTag <a class="header-anchor" href="#_4-revalidatetag" aria-label="Permalink to &quot;4. revalidateTag&quot;">​</a></h3><ul><li><strong>介绍</strong><ul><li>按标签重新验证缓存</li></ul></li><li><strong>配合</strong><ul><li><code>fetch(..., { next: { tags: [&#39;blog&#39;] } })</code></li></ul></li><li><strong>用途</strong><ul><li>精细控制缓存失效</li></ul></li></ul><h3 id="_5-unstable-cache" tabindex="-1">5. unstable_cache <a class="header-anchor" href="#_5-unstable-cache" aria-label="Permalink to &quot;5. unstable_cache&quot;">​</a></h3><ul><li><strong>介绍</strong><ul><li>缓存函数执行结果</li></ul></li><li><strong>参数</strong><ul><li><code>fetchData</code>: 异步函数</li><li><code>keyParts</code>: 缓存键</li><li><code>options</code>: <code>tags</code>, <code>revalidate</code></li></ul></li><li><strong>返回</strong><ul><li>可调用的缓存函数</li></ul></li></ul><h3 id="_6-unstable-nostore" tabindex="-1">6. unstable_noStore <a class="header-anchor" href="#_6-unstable-nostore" aria-label="Permalink to &quot;6. unstable_noStore&quot;">​</a></h3><ul><li><strong>介绍</strong><ul><li>禁用缓存，强制动态渲染</li></ul></li><li><strong>等价于</strong><ul><li><code>fetch(..., { cache: &#39;no-store&#39; })</code></li></ul></li><li><strong>优点</strong><ul><li>比 <code>dynamic = &#39;force-dynamic&#39;</code> 更细粒度</li></ul></li></ul><h3 id="_7-useselectedlayoutsegment" tabindex="-1">7. useSelectedLayoutSegment <a class="header-anchor" href="#_7-useselectedlayoutsegment" aria-label="Permalink to &quot;7. useSelectedLayoutSegment&quot;">​</a></h3><ul><li><strong>介绍</strong><ul><li>获取当前布局下一级的路由段</li></ul></li><li><strong>用途</strong><ul><li>导航高亮、Tab 切换</li></ul></li><li><strong>返回值</strong><ul><li>字符串或 <code>null</code></li></ul></li></ul><h3 id="_8-useselectedlayoutsegments" tabindex="-1">8. useSelectedLayoutSegments <a class="header-anchor" href="#_8-useselectedlayoutsegments" aria-label="Permalink to &quot;8. useSelectedLayoutSegments&quot;">​</a></h3><ul><li><strong>介绍</strong><ul><li>获取当前布局下所有路由段</li></ul></li><li><strong>与 Segment 区别</strong><ul><li>返回数组，包含所有层级</li></ul></li><li><strong>用途</strong><ul><li>面包屑导航</li></ul></li></ul>',44)]))}const m=l(t,[["render",r]]);export{g as __pageData,m as default};
