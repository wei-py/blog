import{_ as i,c as a,o as l,ah as t}from"./chunks/framework.ptg7Kx6M.js";const g=JSON.parse('{"title":"next 渲染机制","description":"","frontmatter":{"title":"next 渲染机制","date":"2025-09-11T00:00:00.000Z","category":"next","tags":["next","render"]},"headers":[],"relativePath":"posts/next/render.md","filePath":"posts/next/render.md"}'),r={name:"posts/next/render.md"};function n(o,e,d,s,c,u){return l(),a("div",null,e[0]||(e[0]=[t('<h1 id="next-js-渲染策略" tabindex="-1">Next.js 渲染策略 <a class="header-anchor" href="#next-js-渲染策略" aria-label="Permalink to &quot;Next.js 渲染策略&quot;">​</a></h1><h2 id="预渲染-pre-rendering" tabindex="-1">预渲染 (Pre-rendering) <a class="header-anchor" href="#预渲染-pre-rendering" aria-label="Permalink to &quot;预渲染 (Pre-rendering)&quot;">​</a></h2><h3 id="两种形式" tabindex="-1">两种形式 <a class="header-anchor" href="#两种形式" aria-label="Permalink to &quot;两种形式&quot;">​</a></h3><ul><li><strong>静态生成 (Static Generation)</strong><ul><li>HTML 在 <strong>构建时 (build time)</strong> 生成</li><li>生成的文件在每次请求时被重用</li><li>可被 CDN 缓存，性能最佳</li><li><strong>推荐</strong> 作为首选方案</li></ul></li><li><strong>服务器端渲染 (Server-side Rendering, SSR)</strong><ul><li>HTML 在 <strong>每次请求时 (request time)</strong> 生成</li><li>无法被 CDN 缓存，TTFB 较慢</li></ul></li></ul><h3 id="混合渲染" tabindex="-1">混合渲染 <a class="header-anchor" href="#混合渲染" aria-label="Permalink to &quot;混合渲染&quot;">​</a></h3><ul><li>Next.js 允许为每个页面单独选择渲染方式</li><li>可以创建混合渲染的应用：大部分页面用静态生成，少数用服务器端渲染</li></ul><h2 id="静态生成-static-generation" tabindex="-1">静态生成 (Static Generation) <a class="header-anchor" href="#静态生成-static-generation" aria-label="Permalink to &quot;静态生成 (Static Generation)&quot;">​</a></h2><h3 id="不带数据" tabindex="-1">不带数据 <a class="header-anchor" href="#不带数据" aria-label="Permalink to &quot;不带数据&quot;">​</a></h3><ul><li>默认行为</li><li>示例: 简单的 About 页面</li></ul><h3 id="带数据" tabindex="-1">带数据 <a class="header-anchor" href="#带数据" aria-label="Permalink to &quot;带数据&quot;">​</a></h3><ul><li>使用 <code>getStaticProps</code><ul><li>在构建时获取数据</li><li>将数据作为 props 传递给页面组件</li></ul></li><li>动态路由页面需配合 <code>getStaticPaths</code><ul><li>指定需要预渲染的动态路径</li><li><code>fallback</code> 选项: <code>false</code>, <code>true</code>, <code>&#39;blocking&#39;</code></li></ul></li></ul><h3 id="增量静态再生-isr" tabindex="-1">增量静态再生 (ISR) <a class="header-anchor" href="#增量静态再生-isr" aria-label="Permalink to &quot;增量静态再生 (ISR)&quot;">​</a></h3><ul><li>通过 <code>revalidate</code> 属性启用</li><li>在不重建整个网站的情况下，按需重新生成静态页面</li><li>兼具静态网站的性能和动态内容的灵活性</li></ul><h2 id="服务器端渲染-ssr" tabindex="-1">服务器端渲染 (SSR) <a class="header-anchor" href="#服务器端渲染-ssr" aria-label="Permalink to &quot;服务器端渲染 (SSR)&quot;">​</a></h2><ul><li>使用 <code>getServerSideProps</code><ul><li>在每次请求时获取数据</li><li>适用于数据频繁更新或高度个性化的页面</li></ul></li><li>性能考量: 仅在绝对必要时使用</li></ul><h2 id="客户端渲染-client-side-rendering" tabindex="-1">客户端渲染 (Client-side Rendering) <a class="header-anchor" href="#客户端渲染-client-side-rendering" aria-label="Permalink to &quot;客户端渲染 (Client-side Rendering)&quot;">​</a></h2><ul><li>与预渲染互补</li><li>适用于用户仪表盘等私有、频繁更新的页面</li><li>推荐使用 <strong>SWR</strong> 这个 React Hook 进行数据获取 <ul><li>自动处理缓存、重新验证、轮询等</li></ul></li></ul>',17)]))}const x=i(r,[["render",n]]);export{g as __pageData,x as default};
