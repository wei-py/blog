import{_ as s,c as a,o as n,ah as o}from"./chunks/framework.ptg7Kx6M.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{"title":"2025-10-09T00:00:00.000Z","date":"2025-10-09T00:00:00.000Z","category":"blog","tags":["blog"]},"headers":[],"relativePath":"posts/2025/10-09.md","filePath":"posts/2025/10-09.md"}'),e={name:"posts/2025/10-09.md"};function r(i,t,l,d,h,p){return n(),a("div",null,t[0]||(t[0]=[o(`<p>要更好地记住和区分 <strong>宏任务（Macro-task）</strong> 与 <strong>微任务（Micro-task）</strong>，可以从以下几个角度入手：<strong>本质区别、执行顺序、记忆口诀、生活类比</strong>。下面为你系统梳理：</p><hr><h3 id="🔑-一、核心区别-本质" tabindex="-1">🔑 一、核心区别（本质） <a class="header-anchor" href="#🔑-一、核心区别-本质" aria-label="Permalink to &quot;🔑 一、核心区别（本质）&quot;">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th>宏任务（Macro-task）</th><th>微任务（Micro-task）</th></tr></thead><tbody><tr><td><strong>执行时机</strong></td><td>每次事件循环（event loop）只执行一个</td><td>在<strong>当前宏任务执行完后、下一个宏任务开始前</strong>，<strong>全部执行完</strong></td></tr><tr><td><strong>优先级</strong></td><td>低</td><td>高</td></tr><tr><td><strong>队列机制</strong></td><td>多个宏任务排队，逐个执行</td><td>一个宏任务结束后，清空整个微任务队列</td></tr><tr><td><strong>典型代表</strong></td><td><code>setTimeout</code>, <code>setInterval</code>, I/O, UI渲染, <code>&lt;script&gt;</code>整体代码</td><td><code>Promise.then/catch/finally</code>, <code>queueMicrotask</code>, <code>MutationObserver</code>, Node.js 中的 <code>process.nextTick</code>（优先级最高）</td></tr></tbody></table><blockquote><p>✅ <strong>关键口诀</strong>： <strong>“宏任务一个一个来，微任务一次清空完。”</strong></p></blockquote><hr><h3 id="🧠-二、记忆技巧" tabindex="-1">🧠 二、记忆技巧 <a class="header-anchor" href="#🧠-二、记忆技巧" aria-label="Permalink to &quot;🧠 二、记忆技巧&quot;">​</a></h3><h4 id="_1-首字母联想" tabindex="-1">1. <strong>首字母联想</strong> <a class="header-anchor" href="#_1-首字母联想" aria-label="Permalink to &quot;1. **首字母联想**&quot;">​</a></h4><ul><li><strong>M</strong>acro → <strong>M</strong>ain / <strong>M</strong>ajor → 主流程，大块任务（如整个 script、定时器）</li><li><strong>M</strong>icro → <strong>M</strong>ini / <strong>M</strong>icro → 小而快，用于“立即响应”的异步操作（如 Promise 回调）</li></ul><h4 id="_2-执行顺序口诀-重点" tabindex="-1">2. <strong>执行顺序口诀（重点！）</strong> <a class="header-anchor" href="#_2-执行顺序口诀-重点" aria-label="Permalink to &quot;2. **执行顺序口诀（重点！）**&quot;">​</a></h4><blockquote><p><strong>“同步代码 → 微任务 → 宏任务 → 微任务 → 宏任务……”</strong></p></blockquote><p>每次事件循环的步骤：</p><ol><li>执行一个宏任务（比如 script 或 setTimeout 回调）</li><li>执行<strong>所有</strong>当前微任务（直到队列为空）</li><li>渲染 UI（浏览器环境）</li><li>取下一个宏任务，重复</li></ol><h4 id="_3-常见例子归类表" tabindex="-1">3. <strong>常见例子归类表</strong> <a class="header-anchor" href="#_3-常见例子归类表" aria-label="Permalink to &quot;3. **常见例子归类表**&quot;">​</a></h4><table tabindex="0"><thead><tr><th>类型</th><th>宏任务（Macro）</th><th>微任务（Micro）</th></tr></thead><tbody><tr><td>浏览器</td><td><code>setTimeout</code>, <code>setInterval</code>, <code>requestAnimationFrame</code>, I/O, 整个 <code>&lt;script&gt;</code></td><td><code>Promise.then/catch</code>, <code>queueMicrotask</code>, <code>MutationObserver</code></td></tr><tr><td>Node.js</td><td><code>setTimeout</code>, <code>setInterval</code>, I/O, <code>setImmediate</code></td><td><code>process.nextTick</code>（⚠️ 比 Promise 更高！）, <code>Promise</code></td></tr></tbody></table><blockquote><p>💡 注意：<code>process.nextTick</code> 虽然属于微任务，但在 Node.js 中它<strong>比 Promise 更早执行</strong>，是“微任务中的 VIP”。</p></blockquote><hr><h3 id="🌰-三、经典例子加深理解" tabindex="-1">🌰 三、经典例子加深理解 <a class="header-anchor" href="#🌰-三、经典例子加深理解" aria-label="Permalink to &quot;🌰 三、经典例子加深理解&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 宏任务</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;3&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 微任务</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;4&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p><strong>输出顺序</strong>：<code>1 → 4 → 3 → 2</code></p><p><strong>解释</strong>：</p><ul><li>同步代码：1, 4</li><li>当前宏任务（script）结束 → 执行所有微任务 → 输出 3</li><li>下一轮事件循环 → 执行 setTimeout 回调 → 输出 2</li></ul><hr><h3 id="🧩-四、生活类比-帮助理解" tabindex="-1">🧩 四、生活类比（帮助理解） <a class="header-anchor" href="#🧩-四、生活类比-帮助理解" aria-label="Permalink to &quot;🧩 四、生活类比（帮助理解）&quot;">​</a></h3><p>想象你在餐厅吃饭：</p><ul><li><strong>宏任务</strong> = 点一道菜（每道菜要等上一轮吃完才能上下一道）</li><li><strong>微任务</strong> = 吃完这道菜后，服务员立刻给你加的免费小菜或调料（必须在下一道主菜前全部上完）</li></ul><p>你不能一边吃主菜一边等下一道主菜；但主菜吃完后，所有“小菜”（微任务）必须先全部上完，才能上下一道主菜（下一个宏任务）。</p><hr><h3 id="✅-总结记忆要点" tabindex="-1">✅ 总结记忆要点 <a class="header-anchor" href="#✅-总结记忆要点" aria-label="Permalink to &quot;✅ 总结记忆要点&quot;">​</a></h3><ol><li><strong>微任务优先级高于宏任务</strong></li><li><strong>一个宏任务 → 清空所有微任务 → 下一个宏任务</strong></li><li><strong>Promise 是微任务，setTimeout 是宏任务</strong>（最容易混淆的点！）</li><li><strong>script 整体代码也是一个宏任务</strong>（很多人忽略！）</li></ol><hr><p>掌握这些，你就能轻松应对面试题和实际开发中的异步逻辑问题！🎯</p><p>非常好的问题！要完整理解浏览器从接收到网页代码到最终显示内容的全过程，<strong>JavaScript 解析器（JS Engine）</strong> 是不可或缺的一环。它不仅负责执行脚本，还会<strong>动态影响 DOM、CSSOM 甚至渲染流程本身</strong>。</p><p>下面我将为你提供一个 <strong>完整、系统、现代浏览器视角下的“从解析到渲染”全流程</strong>，包含 <strong>HTML、CSS、JavaScript 三大解析器</strong> 以及它们如何协同工作。</p><hr><h2 id="🌐-一、浏览器核心组件概览-完整版" tabindex="-1">🌐 一、浏览器核心组件概览（完整版） <a class="header-anchor" href="#🌐-一、浏览器核心组件概览-完整版" aria-label="Permalink to &quot;🌐 一、浏览器核心组件概览（完整版）&quot;">​</a></h2><p>现代浏览器（以 Chromium 为例）主要包含以下核心引擎/模块：</p><table tabindex="0"><thead><tr><th>模块</th><th>负责内容</th><th>典型实现</th></tr></thead><tbody><tr><td><strong>HTML 解析器</strong></td><td>解析 HTML，构建 DOM 树</td><td>Blink（HTML Parser）</td></tr><tr><td><strong>CSS 解析器</strong></td><td>解析 CSS，构建 CSSOM 树</td><td>Blink（CSS Parser）</td></tr><tr><td><strong>JavaScript 引擎</strong></td><td>解析并执行 JS 代码</td><td>V8（Chrome/Edge）、SpiderMonkey（Firefox）、JavaScriptCore（Safari）</td></tr><tr><td><strong>渲染引擎</strong></td><td>布局、绘制、合成</td><td>Blink（含 Layout、Paint、Compositor）</td></tr><tr><td><strong>网络模块</strong></td><td>加载 HTML/CSS/JS/图片等资源</td><td>Chromium Network Stack</td></tr><tr><td><strong>合成器 &amp; GPU 模块</strong></td><td>高效合成图层，GPU 加速</td><td>Viz（Chromium）、WebRender（Firefox）</td></tr></tbody></table><blockquote><p>✅ <strong>关键点</strong>：JS 引擎不是孤立的，它与 HTML/CSS 解析器深度交互，甚至能<strong>中断或重启</strong>渲染流程。</p></blockquote><hr><h2 id="🔁-二、完整渲染流程-含-javascript" tabindex="-1">🔁 二、完整渲染流程（含 JavaScript） <a class="header-anchor" href="#🔁-二、完整渲染流程-含-javascript" aria-label="Permalink to &quot;🔁 二、完整渲染流程（含 JavaScript）&quot;">​</a></h2><p>以下是浏览器加载一个网页时的 <strong>端到端流程</strong>，共 <strong>8 个核心阶段</strong>，JS 的介入贯穿始终：</p><hr><h3 id="_1️⃣-网络请求与字节流接收" tabindex="-1">1️⃣ <strong>网络请求与字节流接收</strong> <a class="header-anchor" href="#_1️⃣-网络请求与字节流接收" aria-label="Permalink to &quot;1️⃣ **网络请求与字节流接收**&quot;">​</a></h3><ul><li>浏览器发起 HTTP(S) 请求，接收 HTML 字节流。</li><li>字节流通过 <strong>编码解码器（Decoder）</strong> 转为字符流（如 UTF-8）。</li></ul><hr><h3 id="_2️⃣-html-解析-预加载扫描-preload-scanner" tabindex="-1">2️⃣ <strong>HTML 解析 + 预加载扫描（Preload Scanner）</strong> <a class="header-anchor" href="#_2️⃣-html-解析-预加载扫描-preload-scanner" aria-label="Permalink to &quot;2️⃣ **HTML 解析 + 预加载扫描（Preload Scanner）**&quot;">​</a></h3><ul><li><strong>HTML 解析器</strong> 逐段解析 HTML，构建 <strong>DOM 树</strong>。</li><li>同时，<strong>预加载扫描器</strong>（非阻塞）提前发现 <code>&lt;script&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;img&gt;</code> 等资源，<strong>并行发起网络请求</strong>，加速加载。</li></ul><blockquote><p>⚠️ 遇到 <code>&lt;script&gt;</code> 标签时：</p><ul><li>若无 <code>async</code>/<code>defer</code>：<strong>阻塞 HTML 解析</strong>，等待 JS 下载并执行。</li><li>若有 <code>async</code>：异步下载，下载完立即执行（可能中断解析）。</li><li>若有 <code>defer</code>：异步下载，<strong>等 DOM 解析完再执行</strong>。</li></ul></blockquote><hr><h3 id="_3️⃣-javascript-解析与执行-关键介入点" tabindex="-1">3️⃣ <strong>JavaScript 解析与执行（关键介入点）</strong> <a class="header-anchor" href="#_3️⃣-javascript-解析与执行-关键介入点" aria-label="Permalink to &quot;3️⃣ **JavaScript 解析与执行（关键介入点）**&quot;">​</a></h3><p>当遇到 JS 脚本时，触发 <strong>JS 引擎</strong> 工作：</p><h4 id="js-引擎内部流程-以-v8-为例" tabindex="-1">JS 引擎内部流程（以 V8 为例）： <a class="header-anchor" href="#js-引擎内部流程-以-v8-为例" aria-label="Permalink to &quot;JS 引擎内部流程（以 V8 为例）：&quot;">​</a></h4><ol><li><strong>词法分析 &amp; 语法分析</strong> → 生成 <strong>AST（抽象语法树）</strong></li><li><strong>字节码生成</strong>（Ignition 解释器）</li><li><strong>热点代码优化</strong>（TurboFan 编译器 → 生成机器码）</li><li><strong>执行 JS 代码</strong></li></ol><h4 id="js-对渲染的影响" tabindex="-1">JS 对渲染的影响： <a class="header-anchor" href="#js-对渲染的影响" aria-label="Permalink to &quot;JS 对渲染的影响：&quot;">​</a></h4><ul><li><strong>修改 DOM</strong>：<code>document.createElement()</code>、<code>innerHTML</code> 等 → 触发 DOM 树变更。</li><li><strong>修改 CSS</strong>：<code>element.style.color = &#39;red&#39;</code> 或 <code>classList.add()</code> → 触发样式重新计算。</li><li><strong>读取布局信息</strong>：如 <code>offsetHeight</code>、<code>getComputedStyle()</code> → <strong>强制同步布局（Layout Thrashing）</strong>。</li><li><strong>创建新资源</strong>：动态插入 <code>&lt;script&gt;</code> 或 <code>fetch()</code> → 触发新网络请求。</li></ul><blockquote><p>✅ <strong>重要</strong>：JS 执行期间，<strong>HTML 解析暂停</strong>（除非 <code>async</code>/<code>defer</code>），<strong>渲染无法继续</strong>。</p></blockquote><hr><h3 id="_4️⃣-css-解析与-cssom-构建" tabindex="-1">4️⃣ <strong>CSS 解析与 CSSOM 构建</strong> <a class="header-anchor" href="#_4️⃣-css-解析与-cssom-构建" aria-label="Permalink to &quot;4️⃣ **CSS 解析与 CSSOM 构建**&quot;">​</a></h3><ul><li>并行下载的 CSS 文件被 <strong>CSS 解析器</strong> 解析为 <strong>CSSOM 树</strong>（样式规则结构化）。</li><li><strong>CSS 是阻塞渲染的</strong>：浏览器不会在 CSSOM 构建完成前开始渲染（避免“无样式内容闪烁” FOUC）。</li></ul><blockquote><p>💡 注意：JS 执行时若依赖样式（如 <code>getComputedStyle</code>），必须等 CSSOM 构建完成。</p></blockquote><hr><h3 id="_5️⃣-样式计算-style-recalculation" tabindex="-1">5️⃣ <strong>样式计算（Style Recalculation）</strong> <a class="header-anchor" href="#_5️⃣-样式计算-style-recalculation" aria-label="Permalink to &quot;5️⃣ **样式计算（Style Recalculation）**&quot;">​</a></h3><ul><li>将 <strong>DOM + CSSOM</strong> 结合，为每个 DOM 节点计算最终的 <strong>Computed Style</strong>。</li><li>输出一棵 <strong>Render Tree</strong>（或称 Style Tree），只包含<strong>可见元素</strong>（<code>display: none</code> 的元素不包含）。</li></ul><blockquote><p>🔄 如果 JS 修改了 class 或 style，此阶段会重新触发。</p></blockquote><hr><h3 id="_6️⃣-布局-layout-reflow" tabindex="-1">6️⃣ <strong>布局（Layout / Reflow）</strong> <a class="header-anchor" href="#_6️⃣-布局-layout-reflow" aria-label="Permalink to &quot;6️⃣ **布局（Layout / Reflow）**&quot;">​</a></h3><ul><li>根据 Render Tree 和视口尺寸，计算每个元素的 <strong>几何信息</strong>（位置、宽高）。</li><li>输出 <strong>Layout Tree</strong>（Box Tree）。</li><li><strong>开销大</strong>，应尽量避免频繁触发。</li></ul><blockquote><p>🔄 JS 读取 <code>offsetTop</code> 等布局属性会强制立即执行布局（即使还没到渲染阶段）。</p></blockquote><hr><h3 id="_7️⃣-绘制-paint-与光栅化-rasterization" tabindex="-1">7️⃣ <strong>绘制（Paint）与光栅化（Rasterization）</strong> <a class="header-anchor" href="#_7️⃣-绘制-paint-与光栅化-rasterization" aria-label="Permalink to &quot;7️⃣ **绘制（Paint）与光栅化（Rasterization）**&quot;">​</a></h3><ul><li>将 Layout Tree 分解为 <strong>绘制指令</strong>（如“画一个红色矩形”）。</li><li><strong>光栅化</strong>：将指令转为像素位图（CPU 或 GPU）。</li><li>页面被划分为 <strong>图块（Tiles）</strong>，按需绘制和缓存。</li></ul><hr><h3 id="_8️⃣-合成-compositing-与显示" tabindex="-1">8️⃣ <strong>合成（Compositing）与显示</strong> <a class="header-anchor" href="#_8️⃣-合成-compositing-与显示" aria-label="Permalink to &quot;8️⃣ **合成（Compositing）与显示**&quot;">​</a></h3><ul><li>合成器将多个图层（如滚动层、视频层）<strong>GPU 合成</strong>为最终帧。</li><li>通过 <strong>双缓冲</strong>、<strong>垂直同步（VSync）</strong> 机制，以 60fps（或更高）显示到屏幕。</li></ul><hr><h2 id="🧩-三、js-如何打断渲染流程-关键交互点" tabindex="-1">🧩 三、JS 如何打断渲染流程？（关键交互点） <a class="header-anchor" href="#🧩-三、js-如何打断渲染流程-关键交互点" aria-label="Permalink to &quot;🧩 三、JS 如何打断渲染流程？（关键交互点）&quot;">​</a></h2><table tabindex="0"><thead><tr><th>场景</th><th>影响</th></tr></thead><tbody><tr><td><code>&lt;script&gt;</code> 无属性</td><td>阻塞 HTML 解析，延迟 DOM 构建</td></tr><tr><td>JS 修改 DOM</td><td>触发样式重算 + 布局 + 绘制</td></tr><tr><td>JS 读取布局属性</td><td>强制同步执行布局（性能陷阱）</td></tr><tr><td><code>requestAnimationFrame()</code></td><td>在合成前插入自定义逻辑（动画最佳实践）</td></tr><tr><td><code>Promise</code> / <code>setTimeout</code></td><td>将任务推迟到下一帧，避免阻塞渲染</td></tr></tbody></table><hr><h2 id="🖼️-四、完整流程图-文字版" tabindex="-1">🖼️ 四、完整流程图（文字版） <a class="header-anchor" href="#🖼️-四、完整流程图-文字版" aria-label="Permalink to &quot;🖼️ 四、完整流程图（文字版）&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>网络请求</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>HTML 字节流 → [HTML Parser] → DOM 树</span></span>
<span class="line"><span>   │               ↑</span></span>
<span class="line"><span>   │               └── 遇到 &lt;script&gt; → 暂停解析 → [JS Engine]</span></span>
<span class="line"><span>   │                                   ↓</span></span>
<span class="line"><span>   │                           执行 JS → 可能修改 DOM/CSS</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>CSS 文件 → [CSS Parser] → CSSOM 树</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>DOM + CSSOM → [Style Engine] → Render Tree（带样式的可见节点）</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>[Layout Engine] → 计算位置/尺寸 → Layout Tree</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>[Paint] → 生成绘制指令 → [Raster] → 位图（图块）</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>[Compositor] → 合成图层 → GPU → 屏幕</span></span></code></pre></div><hr><h2 id="🚀-五、现代浏览器优化-多线程-流水线" tabindex="-1">🚀 五、现代浏览器优化（多线程 &amp; 流水线） <a class="header-anchor" href="#🚀-五、现代浏览器优化-多线程-流水线" aria-label="Permalink to &quot;🚀 五、现代浏览器优化（多线程 &amp; 流水线）&quot;">​</a></h2><p>为提升性能，现代浏览器采用 <strong>多进程/多线程架构</strong>：</p><ul><li><strong>主线程（Main Thread）</strong>：HTML 解析、JS 执行、样式计算、布局。</li><li><strong>光栅化线程（Raster Thread）</strong>：在后台将绘制指令转为位图。</li><li><strong>合成线程（Compositor Thread）</strong>：独立于主线程，处理滚动、动画合成。</li><li><strong>网络线程</strong>：并行下载资源。</li></ul><blockquote><p>✅ 这使得即使 JS 阻塞主线程，<strong>滚动或 CSS 动画仍可流畅运行</strong>（如果它们在合成层上）。</p></blockquote><hr><h2 id="✅-总结-完整渲染流程包含三大解析器" tabindex="-1">✅ 总结：完整渲染流程包含三大解析器 <a class="header-anchor" href="#✅-总结-完整渲染流程包含三大解析器" aria-label="Permalink to &quot;✅ 总结：完整渲染流程包含三大解析器&quot;">​</a></h2><table tabindex="0"><thead><tr><th>解析器</th><th>作用</th><th>与其他模块交互</th></tr></thead><tbody><tr><td><strong>HTML 解析器</strong></td><td>构建 DOM</td><td>被 JS 阻塞；触发资源加载</td></tr><tr><td><strong>CSS 解析器</strong></td><td>构建 CSSOM</td><td>阻塞渲染；JS 可能依赖它</td></tr><tr><td><strong>JS 引擎</strong></td><td>执行脚本</td><td>可修改 DOM/CSSOM，触发重排重绘</td></tr></tbody></table><blockquote><p>🌟 <strong>核心思想</strong>：浏览器渲染不是线性单向过程，而是一个 <strong>动态、可中断、可回溯的事件驱动系统</strong>，JS 是其中最活跃的“搅局者”也是“控制者”。</p></blockquote><hr><p>如果你想深入了解某一部分（比如 V8 如何优化 JS、合成层如何创建、或如何避免 Layout Thrashing），欢迎继续提问！</p><p>defer 模式下，JS 的加载是异步的，执行是被推迟的。等整个文档解析完成、DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始依次执行。</p><p>从应用的角度来说，一般当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。</p><p>通过审时度势地向 script 标签添加 async/defer，我们就可以告诉浏览器在等待脚本可用期间不阻止其它的工作，这样可以显著提升性能。</p>`,95)]))}const k=s(e,[["render",r]]);export{g as __pageData,k as default};
