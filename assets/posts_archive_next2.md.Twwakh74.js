import{_ as e,c as o,o as l,ah as r}from"./chunks/framework.ptg7Kx6M.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"posts/archive/next2.md","filePath":"posts/archive/next2.md"}'),a={name:"posts/archive/next2.md"};function s(n,t,i,d,c,g){return l(),o("div",null,t[0]||(t[0]=[r('<p>好的，根据您提供的两篇关于 Next.js 缓存机制的文档，我为您总结如下：</p><p>Next.js 拥有一套强大且复杂的缓存体系，旨在优化性能和降低成本。这套体系包含四种主要的缓存机制，它们在不同的层面、不同的位置工作，共同协作。</p><hr><h3 id="一、-四种缓存机制概览" tabindex="-1"><strong>一、 四种缓存机制概览</strong> <a class="header-anchor" href="#一、-四种缓存机制概览" aria-label="Permalink to &quot;**一、 四种缓存机制概览**&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">机制</th><th style="text-align:left;">缓存内容</th><th style="text-align:left;">存储位置</th><th style="text-align:left;">主要目的</th><th style="text-align:left;">持续时间</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>1. 请求记忆 (Request Memoization)</strong></td><td style="text-align:left;">函数返回值</td><td style="text-align:left;">服务端内存</td><td style="text-align:left;">在单个请求的 React 组件树渲染过程中，避免对同一数据的重复请求</td><td style="text-align:left;">每个请求的生命周期</td></tr><tr><td style="text-align:left;"><strong>2. 数据缓存 (Data Cache)</strong></td><td style="text-align:left;">数据 (如 fetch 结果)</td><td style="text-align:left;">服务端</td><td style="text-align:left;">跨用户请求和部署复用数据，减少对数据源的访问</td><td style="text-align:left;">持久，除非重新验证或退出</td></tr><tr><td style="text-align:left;"><strong>3. 完整路由缓存 (Full Route Cache)</strong></td><td style="text-align:left;">HTML 和 RSC Payload</td><td style="text-align:left;">服务端</td><td style="text-align:left;">复用整个路由的渲染结果，极大降低服务端渲染成本</td><td style="text-align:left;">持久，跨部署后清除</td></tr><tr><td style="text-align:left;"><strong>4. 路由缓存 (Router Cache)</strong></td><td style="text-align:left;">RSC Payload</td><td style="text-align:left;">客户端浏览器内存</td><td style="text-align:left;">减少导航时的服务端请求，实现快速、无刷新的页面切换</td><td style="text-align:left;">用户会话期间或基于时间（静态5分钟，动态30秒）</td></tr></tbody></table><hr><h3 id="二、-详细解析" tabindex="-1"><strong>二、 详细解析</strong> <a class="header-anchor" href="#二、-详细解析" aria-label="Permalink to &quot;**二、 详细解析**&quot;">​</a></h3><h4 id="_1-请求记忆-request-memoization" tabindex="-1"><strong>1. 请求记忆 (Request Memoization)</strong> <a class="header-anchor" href="#_1-请求记忆-request-memoization" aria-label="Permalink to &quot;**1. 请求记忆 (Request Memoization)**&quot;">​</a></h4><ul><li><strong>本质</strong>：这是 React 的特性，而非 Next.js 特有。它通过“函数记忆”原理工作，对在同一个 React 组件树渲染过程中发起的、参数相同的 <code>fetch</code> 请求进行去重。</li><li><strong>作用域</strong>：仅在 React 组件树内有效（如 <code>layout</code>, <code>page</code>, <code>generateMetadata</code> 等）。</li><li><strong>持续时间</strong>：仅存在于一次服务器请求的整个渲染周期内。渲染结束后，缓存即被清除。</li><li><strong>退出方式</strong>：不建议退出。若必须，可使用 <code>AbortController</code> 创建不同的 <code>signal</code> 对象来“欺骗”缓存机制，使其认为是不同的请求。</li></ul><h4 id="_2-数据缓存-data-cache" tabindex="-1"><strong>2. 数据缓存 (Data Cache)</strong> <a class="header-anchor" href="#_2-数据缓存-data-cache" aria-label="Permalink to &quot;**2. 数据缓存 (Data Cache)**&quot;">​</a></h4><ul><li><strong>本质</strong>：这是 Next.js 提供的持久化缓存，可以跨多个用户请求和应用部署共享数据。</li><li><strong>配置方式</strong>： <ul><li><code>fetch(url, { cache: &#39;force-cache&#39; })</code>: 强制缓存（默认行为）。</li><li><code>fetch(url, { cache: &#39;no-store&#39; })</code>: 强制不缓存，每次请求都从源获取。</li><li><code>fetch(url, { next: { revalidate: 3600 } })</code>: 基于时间的重新验证，例如每3600秒（1小时）后，有新请求到来时会触发后台更新。</li><li><code>export const revalidate = 3600</code>: 路由段配置，作用于该段内所有 <code>fetch</code> 请求。</li></ul></li><li><strong>按需重新验证</strong>： <ul><li><strong>基于标签 (<code>revalidateTag</code>)</strong>: 为 <code>fetch</code> 请求打上标签（<code>next: { tags: [&#39;news&#39;] }</code>），然后通过 <code>revalidateTag(&#39;news&#39;)</code> 来清除所有带此标签的缓存。</li><li><strong>基于路径 (<code>revalidatePath</code>)</strong>: 通过 <code>revalidatePath(&#39;/dashboard&#39;)</code> 来清除特定路径相关的缓存。</li></ul></li><li><strong>退出方式</strong>：使用 <code>cache: &#39;no-store&#39;</code> 或 <code>dynamic = &#39;force-dynamic&#39;</code>。</li></ul><h4 id="_3-完整路由缓存-full-route-cache" tabindex="-1"><strong>3. 完整路由缓存 (Full Route Cache)</strong> <a class="header-anchor" href="#_3-完整路由缓存-full-route-cache" aria-label="Permalink to &quot;**3. 完整路由缓存 (Full Route Cache)**&quot;">​</a></h4><ul><li><strong>内容</strong>：缓存的是路由在构建时或首次请求时生成的最终产物——<strong>HTML</strong> 和 <strong>RSC Payload</strong>。</li><li><strong>适用范围</strong>：<strong>仅适用于静态渲染 (Static Rendering)</strong> 的路由。动态渲染的路由无法被完整路由缓存。</li><li><strong>持续时间</strong>：持久化存储在服务端。</li><li><strong>失效方式</strong>： <ol><li><strong>重新验证数据</strong>：当路由依赖的数据缓存被重新验证并更新时，完整路由缓存也会随之失效并重建。</li><li><strong>重新部署</strong>：每次应用重新部署，完整路由缓存都会被清除。</li></ol></li><li><strong>退出方式</strong>：将路由转为动态渲染。方法包括： <ul><li>使用 <code>dynamic = &#39;force-dynamic&#39;</code> 或 <code>revalidate = 0</code>。</li><li>路由中包含 <code>no-store</code> 的 <code>fetch</code> 请求。</li><li>使用 <code>cookies</code> 或 <code>headers</code> 等动态函数。</li></ul></li></ul><h4 id="_4-路由缓存-router-cache" tabindex="-1"><strong>4. 路由缓存 (Router Cache)</strong> <a class="header-anchor" href="#_4-路由缓存-router-cache" aria-label="Permalink to &quot;**4. 路由缓存 (Router Cache)**&quot;">​</a></h4><ul><li><strong>本质</strong>：客户端的内存缓存，存储的是从服务端获取的 <strong>RSC Payload</strong>。</li><li><strong>工作原理</strong>：当用户通过 <code>&lt;Link&gt;</code> 导航时，Next.js 会预获取目标路由的 RSC Payload 并存入此缓存。再次访问时，直接从缓存中读取，无需网络请求，实现瞬时跳转。</li><li><strong>持续时间</strong>： <ul><li><strong>静态路由</strong>：缓存5分钟。</li><li><strong>动态路由</strong>：缓存30秒。</li><li>页面刷新后，缓存会被清除。</li></ul></li><li><strong>失效方式</strong>： <ul><li>调用 <code>router.refresh()</code>。</li><li>在 Server Actions 中调用 <code>revalidatePath</code> 或 <code>revalidateTag</code>。</li><li>在 Server Actions 中修改 <code>cookies</code>。</li></ul></li><li><strong>重要提示</strong>：<strong>无法完全退出</strong>。即使将 <code>&lt;Link prefetch={false}&gt;</code>，访问过的路由仍会临时缓存30秒以支持嵌套路由的即时导航。</li></ul><hr><h3 id="三、-关键区别与实战要点" tabindex="-1"><strong>三、 关键区别与实战要点</strong> <a class="header-anchor" href="#三、-关键区别与实战要点" aria-label="Permalink to &quot;**三、 关键区别与实战要点**&quot;">​</a></h3><ul><li><p><strong>请求记忆 vs 数据缓存</strong>：</p><ul><li><strong>请求记忆</strong>是单次请求内的“去重”，是 React 的优化。</li><li><strong>数据缓存</strong>是跨请求的“持久化”，是 Next.js 的核心功能。</li><li>两者通常同时存在。实战中，即使关闭了数据缓存，请求记忆仍可能导致多次调用返回相同数据。</li></ul></li><li><p><strong>完整路由缓存 vs 路由缓存</strong>：</p><ul><li><strong>完整路由缓存</strong>在<strong>服务端</strong>，针对<strong>静态路由</strong>，缓存的是<strong>HTML + RSC Payload</strong>。</li><li><strong>路由缓存</strong>在<strong>客户端</strong>，针对<strong>所有路由</strong>（静/动），缓存的是<strong>RSC Payload</strong>。</li></ul></li><li><p><strong>开发痛点</strong>：路由缓存是“双刃剑”。它提供了丝滑的用户体验，但也常导致数据不更新（如导航后时间未变）。开发者必须理解其存在，并在需要实时数据时，通过 <code>router.refresh()</code> 或修改 <code>cookies</code> 等方式主动使其失效。</p></li><li><p><strong>API 与缓存关系</strong>：文档末尾的表格是解决缓存问题的“万能钥匙”。当遇到数据未更新时，应先回顾使用了哪些 API，然后根据表格判断影响了哪种缓存，再选择对应的重新验证或退出策略。</p></li></ul><hr><p><strong>总结</strong>：Next.js 的缓存机制设计精妙，自动化程度高。理解这四种缓存的层级、作用域和生命周期，是高效开发和调试 Next.js 应用的关键。开发者应善用缓存提升性能，同时也要掌握控制缓存的“开关”和“扳手”，以应对数据实时性等复杂场景。</p>',20)]))}const f=e(a,[["render",s]]);export{u as __pageData,f as default};
